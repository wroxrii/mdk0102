# Конспект от 27 января 2023 по теме:
### Обработка исключений 
#### Типы ошибок
Разработка программы на любом языке программирования практически всегда бывает связана с возникновением различного рода ошибок, препятствующих получению желаемого результата.

Выделяют следующие три категории ошибок:
- **синтаксические** - возникают из-за синтаксических погрешностей кода
- **логические** - проявляются вследствие логических неточностей в алгоритме
- **исключения, ошибки времени выполнения** - вызваны некорректными действиями пользователя или системы
#
#### Синтаксические ошибки
Синтаксические ошибки являются следствием несоблюдения общепринятого синтаксиса языка.

Другими словами, это ошибки, связанные с неправильно набранным кодом.

###### Например:
```
print('Hello, world!'
```
###### Выведет:
```
SyntaxError: '(' was never closed
```
Допущена синтаксическая ошибка: **отсутствует закрывающая скобка** в вызове функции `print()`.



###### Другой пример:
```
def square(num)
    return num ** 2
```
###### Выведет:
```
SyntaxError: expected ':'
```
Допущена синтаксическая ошибка: **пропущен символ двоеточия** в описании функции.

#
#### Логические ошибки
Логические ошибки считаются более сложными в выявлении, поскольку не отлавливаются интерпретатором.

Обычно они вызваны определенным недостатком в логике программы, из-за чего результат работы программы отличается от желаемого результата.

Возможным решением проблемы является тестирование программы на разных примерах входных данных, для которых известен правильный результат.

Например, функция `avg()`, подсчитывающая среднее значение переданных в нее аргументов:
```
def avg(a, b):
    return a + b / 2
print(avg(0, 7))
print(avg(6, 14))
```
###### Выведет:
```
3.5
13
```
В теле функции допущена **логическая** ошибка, пропущены скобки, на два должна делиться сумма чисел a и b, а не только b.
> Логические ошибки могут проявлять себя только при определенных условиях.
#
#### Исключения
Исключительные ситуации или исключения (exceptions) - это ошибки, обнаруженные при исполнении.

Исключения проявляются в зависимости от наличия обстоятельств, меняющих ход выполнения программы, связанны с некорректностью переданных в программу данных, недоступностью ресурсов и так далее.

Например, к чему приведет попытка чтения несуществующего файла? Или если файл был случайно удален, пока программа работала? Такие ситуации обрабатываются при помощи исключений.
###### Например:
```
num1 = 10
num2 = 0
print(num1 / num2)
```
###### Выведет:
```
ZeroDivisionError: division by zero
```
Деление на ноль провоцирует исключительную ситуацию, которая приводит к аварийному завершению работы и выводу ошибки на экран. `ZeroDivisonError` - это название исключения, а `division by zero` - его краткое описание.
> При обнаружении необработанного исключения Python немедленно останавливает выполнение программы и выводит сообщение об ошибке!
#
#### Работа с кодами возврата
У работы с исключениями есть преимущества перед кодами возврата. В современных языках программирования, таких как Python, C#, Java, GO и так далее, используются именно исключения.

Несмотря на то, что язык Python полностью поддерживает работу с исключениями, как с полноценными объектами, мы все же можем встретить следы работы с кодами возврата, которые Python унаследовал от языка C.

Например: Строковый тип данных `str` содержит два похожих метода: `find()` и `index()`.

Оба метода ищут позицию первого вхождения подстроки в заданную строку.

###### Следующий программный код:
```
text = 'Hello, world!'
print(text.find('w'))
print(text.find('a'))
print(text.index('a'))
```
###### Выводит:
```
7
-1
ValueError: substring not found
```

Метод `find()` использует механизм кодов возврата.

Метод `index()` возбуждает исключение.

#
### Обработка исключений
#### Основные типы исключений
**Общая идея:**

Программный код, в котором теоретически может возникнуть ошибка, выделяется специальным образом - *берётся на контроль*.

Если при выполнении этого программного кода ошибка не возникает, то ничего не происходит.

Если при выполнении *контролируемого* кода возникает ошибка, то выполнение кода останавливается и автоматически создается объект-исключение, содержащий описание возникшей ошибки.

Для обработки исключительных ситуаций в языке Python используется конструкция **try-except**.

Поле ключевого слова **try** и двоеточия размещается блок программного кода, который мы подозреваем на предмет возможного возникновения ошибки.

Этот код называется **контролируемым**.

По завершении этого блока указывается ключевое слово **except** (с двоеточием), после которого идет еще один блок программного кода.

Этот код называется **кодом обработки ошибки (исключения)**.

Шаблон конструкции обработки исключений:
```
try:
    # контролируемый код
except:
    # код обработки ошибки (исключения)
```

###### Пример:
```
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except:
    print('Вы ввели некорректные данные!')
```
###### Пример ввода 1:
```
abc
Вы ввели некорректные данные!
```
В данном случае введена строка вместо числа, из-за чего возникнет ошибка `ValueError: invalid literal for int() with base 10: 'abc'`, которая возникает при попытке преобразовать недопустимый объект в целое число.

###### Пример ввода 2:
```
10
0
Вы ввели некорретные данные!
```
В данном случае делитель равен нулю, из-за чего возникнет ошибка `ZeroDivisionError: division by zero`, которая возникает при попытке поделить на ноль.

> Такая схема обработки ошибок (исключений), проста и удобна. Но недостаток ее в том, что **разные ошибки (исключения) обрабатываются одинаково.** То есть, какая бы ни возникла ошибка (исключение), реакция программы будет одна и та же.
#
#
#
### Методики LBYL и EAFP
При написании программного кода, который может потенциально возбуждать исключения, существуют два основных подхода:

LBYL (Look Before You Leap) - посмотри перед прыжком

EAFP (Easier to Ask Forgiveness than Permission) - проще извиниться, чем спрашивать разрешение

###### Приведенный ниже код
```
data = {'Timur': 29, 'Ivan': 54}
data['Anri'] += 1
```
> Приводит к возникновению исключения **KeyError**.
###### Можно исправить такой код двумя способами.
```
data = {'Timur': 29, 'Ivan': 54}
if 'Anri' in data:
    data['Anri'] += 1
else:
    print('Ключ Anri отсутствует в словаре.')
```
> Перестраховаться и заранее проверить, что все получится. Это идеология **LBYL-подхода**. Сначала посмотрели, убедились, что все в порядке, только потом сделали.

###### Второй способ
```
data = {'Timur': 29, 'Ivan': 54}
try:
    data['Anri'] += 1
except KeyError:
    print('Ключ Anri отсутствует в словаре.')
```
> Мы можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но при таком подходе необходимо прописать действия с исключениями (иногда разных типов). Это суть подхода **EAFP**.

### Оператор assert
Оператор **assert** позволяет писать проверки работоспособности кода. Эти проверки называют **утверждениями**. Используются такие утверждения для того чтобы убедиться, остаются ли верными определенне условия во время разработки программы.

Если какие-либо из утверждений оказывается ложным, то это означает, что в программе есть ошибка. Если все утверждения истинны, то в прорамме ошибок нет.

Оператор assert - это встроенный оператор используемый для проверки того, является ли заданное утверждение истинным или ложным.

Если утверждение истинно, то ничего не происходит и выполняется следующая строка кода.

Если же утверждение ложно, оператор **assert** остаенавливает выполнение программы и подобно оператору **raise** возбуждает исключение **AssertionError**.

Синтаксис использования оператора **assert** следующий:
```
assert <утверждение>
```
Также можно добавить дополнительное сообщение, которое описывает подробности возникновения исключительной ситуации. В таком случае синтаксис оператора assert будет следующий:
```
assert <утверждение>, <сообщение>
```

### Примеры использования оператора assert
```
age = -29
assert age > 0, 'Возраст - положительное число!'
```
###### Результат
```
AssertionError: Возраст - положительное число!
```
